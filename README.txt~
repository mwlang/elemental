= ELEMENTAL

Elemental gives you enumerated sets.  You code symbolically,
but your symbols (now elements) are very rich in nature.

== REQUIREMENTS:

  * Ruby 1.8+
  * Ruby Gems

== INSTALL:

From Gem:
    sudo gem install elemental

From Source:
    gem install bones, rake, test-unit
    git clone git://github.com/mwlang/elemental.git
    cd elemental
    rake gem:package
    cd pkg
    sudo gem install elemental

== DESCRIPTION:

Elemental provides enumerated collection of elements that allow you to
associate ruby symbols to arbitrary values, thus allowing your code to
"think" symbolically and unambiguously while giving you the means to
easily display what end-users need to see.  Additionally, symbols are
associated with ordinal values, allowing easy storage/retrieval to
persistent stores (e.g. databases).

In your code, instead of:

  if User.status == 'Active' ...

...which is error prone and hard to test.  With Elemental, do this:

  if User.status == UserStatus::active

If UserStatus::active isn't defined, you get an error immediately that you can
attribute to a typo in your code.  This behavior is by design in Elemental.
That's a unit test you *don't* have to write!

== FEATURES/PROBLEMS:

    * Code with symbols, easily display what the user needs to see.
    * Change the display values without worrying about logical side-effects.
    * Access elements in a variety of ways: symbol, constant, index.
    * Store in database as either string (the default) or ordinal value.

== SYNOPSIS:

Establish Elementals like this:

class AccountStatus < Elemental
  member :active,       :display => 'Active', :default => true
  member :delinquent,   :display => "Account Past Due"
  member :inactive      :display => "Inactive"
end

class Fruit < Elemental
  member :orange,       :position => 10
  member :banana,       :position => 5,  :default => true
  member :blueberry,    :position => 15
end

Whereas:
    * The symbol is main accessor for Elemental
    * Display is what the end-user sees. Display defaults to the symbol's to_s.
    * Position lets you define a display sort order (use WidgetType.sort...)
    * Position defaults to Ordinal value if not given.
    * Default sort order is the order in which elements are declared (ordinal).
    * Specifying Position does not change Ordinal value.

Another example:

class Color < Elemental
  member :red,      :display "#FF0000"
  member :green,    :display "#00FF00"
  member :blue,     :display "#0000FF"
end

So you roll with this for a few months and decided you don't like primary colors?
Its simple to change the color constants (in display):

class Color < Elemental
  member :red,      :display "#AA5555"
  member :green,    :display "#55AA55"
  member :blue,     :display "#5555AA"
end

Your code logic remains the same because the symbols didn't change!

To get this benefit, replace your conditionals that use string literals.

So, instead of:
  if widget.widget_type == "Foo bar"

(where widget is an Activerecord instance and widget_type is an attribute/column)
(mental note: was that "FOO BAR", "foobar", "Foo Bar", "foo bar", or "Foo bar"??)

Do this and be confident:
  if WidgetType[widget.widget_type] == WidgetType::foo_bar

Or shorter:
  if WidgetType[widget.widget_type].is?(WidgetType::foo_bar)

Or shorter, still:
  if WidgetType[widget.widget_type].is?(:foo_bar)

Seriously:
    def test_is_conditional
      assert_equal(true, Fruit::banana.is?(:banana))
      assert_equal(true, Fruit::banana.is?(Fruit::banana))
      assert_equal(false, Fruit::banana.is?(:kiwi))
      assert_equal(true, TalkingNumbers[1].is?(:uno))
      assert_equal(true, TalkingNumbers[2].is?("dos"))
      assert_equal(true, TalkingNumbers["tres"].is?(3))
    end

For Rails, You can stop hitting database for small, rarely changing lists.

With Elemental, simply populate select dropdowns like this:

  <p><label for="widget_type">Type</label><br/>
    <%= select "widget", "widget_type",
      WidgetType.sort.map{|wt| [wt.display, wt.value]},
      { :include_blank => false,
        :selected => WidgetType.defaults.first.value }
    %></select>
  </p>

More than one default is supported (dropdowns only use one, so first.value
gets you first one, radio buttons or checkboxes can use all defaults). Ordinal
position is preserved and traditionally shouldn't be changed during the life
of the project, although, Ruby being Ruby and developers saying "Ruby ain't C,"
an Elemental's elements almost definitely will get changed by some developer at
some time. As such, the default behavior for "value" is to return the symbol
rather than ordinal value and storing as a string in DB, which seems the safest
route to take albeit not the optimal performance-wise (finding records by
integral value is faster than string searches, even with indexes in place).
If you want to override this, simply call "persist_ordinally" when you
declare your Elemental classes.

class Color < Elemental
  persist_ordinally
  member :red
  member :green
  member :blue
end

With that, Color::red.value returns Fixnum 0 instead of Symbol :red

Elements can be accessed multiple ways:

def test_different_retrievals_get_same_element
  a1 = Car::honda
  a2 = Car::Honda
  a3 = Car[:honda]
  a4 = Car[:Honda]
  a5 = Car["Honda"]
  a6 = Car["honda"]
  a7 = Car.first
  a8 = Car.last.succ
  a9 = Car[0]
  assert_element_sameness(a1, a2, :honda)
  assert_element_sameness(a2, a3, :honda)
  assert_element_sameness(a4, a5, :honda)
  assert_element_sameness(a6, a7, :honda)
  assert_element_sameness(a8, a1, :honda)
  assert_element_sameness(a9, a2, :honda)
end

There are also several convenience aliases to pull ordinal, value, symbol and display:

def test_aliases
  assert_equal(Car::toyota.index, Car::toyota.to_i)
  assert_equal(Car::toyota.to_i, Car::toyota.to_i)
  assert_equal(Car::toyota.to_int, Car::toyota.to_i)
  assert_equal(Car::toyota.ord, Car::toyota.to_i)
  assert_equal(Car::toyota.ordinal, Car::toyota.to_i)
  assert_equal(Car::toyota.to_sym, Car::toyota.value)
  assert_equal(:toyota, Car::toyota.to_sym)
  assert_equal(:toyota, Car::toyota.value)
  assert_equal("toyota", Car::toyota.display)
  assert_equal("toyota", Car::toyota.humanize)
end

Full test coverage is provided.

== LICENSE:

(The MIT License)

Copyright (c) 2009 Michael Lang

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
